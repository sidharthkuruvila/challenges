* Load the input data into a table

#+begin_src awk :in-file ../../input/day06/input.txt :results value file :file letters.csv
  {
      for(i = 1; i <= length($0); i++) {
          print i","substr($0, i, 1)
      }
  }
#+end_src

#+RESULTS:
[[file:letters.csv]]


Load csv file into a table

#+begin_src sqlite :db ./day06.db
  drop table if exists letters;	
  create table letters(id, chr string);
  .mode csv letters
  .import letters.csv letters
#+end_src

#+RESULTS:

#+begin_src sqlite :db ./day06.db :colnames yes :exports both
  select * from letters limit 10
#+end_src

#+RESULTS:
| id | chr |
|----+-----|
|  1 | d   |
|  2 | v   |
|  3 | g   |
|  4 | d   |
|  5 | v   |
|  6 | v   |
|  7 | b   |
|  8 | p   |
|  9 | b   |
| 10 | t   |


* Counting bits
#+begin_src sqlite :db ./day06.db
  drop table if exists single_bits;
  create table single_bits as
  with
  numbers(n) as (
             select 0
             union all
             select n + 1 from numbers where n < 26
             ),
  bits(b) as (
          select 1 << n from numbers
  )
  select * from bits
#+end_src

#+RESULTS:

#+begin_src sqlite :db ./day06.db :colnames yes :exports both
          select * from single_bits limit 10
#+end_src

#+RESULTS:
|   b |
|-----|
|   1 |
|   2 |
|   4 |
|   8 |
|  16 |
|  32 |
|  64 |
| 128 |
| 256 |
| 512 |

* Part 1

The algorithm
1. Conver the list of characters to a list of where each character is represented by a single bit.
2. Construct windows of size 4 over the list of ints.
3. And all the bits in each window   
4. Count the bits in each window.
5. Select the fist window containing 4 bits.

Note: Sqlite's windowing functions do not include one that bitwise ands all values in the windows, a sum was used instead. The sum has a looser guarantee that the number generated by the sum will be at most the number of bits.

#+begin_src sqlite :db ./day06.db :colnames yes :exports both
  with         
       bit_set(id, b) as (select id, 1 << (unicode(chr) - unicode('a')) from letters),
       agg(id, n) as (select id, sum(b) over (rows between current row and 3 following) from bit_set),
       as_bits(id, n, b) as (select id, n, b & n  from agg join single_bits),
       counts(id, n, c) as (select id, n, count(*)  from agg join single_bits  where b & n !=  0 group by id)
       select id + 3 as Result from counts where c = 4 limit 1
#+end_src

#+RESULTS:
| Result |
|--------|
|   1965 |

* Part 2

#+begin_src sqlite :db ./day06.db :colnames yes :exports both
  with         
       bit_set(id, b) as (select id, 1 << (unicode(chr) - unicode('a')) from letters),
       agg(id, n) as (select id, sum(b) over (rows between current row and 13 following) from bit_set),
       as_bits(id, n, b) as (select id, n, b & n  from agg join single_bits),
       counts(id, n, c) as (select id, n, count(*)  from agg join single_bits  where b & n !=  0 group by id)
       select id + 13 as Result  from counts where c = 14 limit 1
#+end_src

#+RESULTS:
| Result |
|--------|
|   2773 |
