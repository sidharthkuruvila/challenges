* Load input into sqlite

#+begin_src awk :in-file ../../input/day01/input.txt :results value file :file input.csv
  BEGIN {
      line_id = 1
  }

  {
      for(i = 1; i<=length($0);i++){
          print line_id","i","substr($0,i,1)
      }
      line_id++
  }
#+end_src

#+RESULTS:
[[file:input.csv]]


Load csv file into a table

#+begin_src sqlite :db ./day01.db
  drop table if exists input;	
  create table input(line_id int, char_id int,  chr string);
  .mode csv input
  .import input.csv input
#+end_src

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select * from input limit 10
#+end_src

#+RESULTS:
| line_id | char_id | chr |
|---------+---------+-----|
|       1 |       1 | 9   |
|       1 |       2 | e   |
|       1 |       3 | i   |
|       1 |       4 | g   |
|       1 |       5 | h   |
|       1 |       6 | t   |
|       1 |       7 | o   |
|       1 |       8 | n   |
|       1 |       9 | e   |
|       2 |       1 | h   |


* Part 1

Filter out non digit characters from each line

#+begin_src sqlite :db ./day01.db
drop table if exists ints;
create table ints as
select line_id, char_id, chr
from input
where chr >= '0'
  and chr <= '9'
#+end_src

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select group_concat(chr) from ints group by line_id limit 10
#+end_src

#+RESULTS:
| group_concat(chr) |
|-------------------|
| 9                 |
| 3,5,4             |
| 9                 |
| 8,8,6             |
| 6,2               |
| 2,3,4             |
| 2,8               |
| 2,2,3             |
| 2                 |
| 7,8,1,9,7,2,6     |

Find the first digit that appears in each line

#+begin_src sqlite :db ./day01.db
drop table if exists minimums;
create table minimums as
with min_char_id(line_id, char_id) as (select line_id, min(char_id) from ints group by line_id)
select line_id, chr
from ints
         join min_char_id using (line_id, char_id)
#+end_src	

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select line_id, chr from minimums  limit 10
#+end_src

#+RESULTS:
| line_id | chr |
|---------+-----|
|       1 |   9 |
|       2 |   3 |
|       3 |   9 |
|       4 |   8 |
|       5 |   6 |
|       6 |   2 |
|       7 |   2 |
|       8 |   2 |
|       9 |   2 |
|      10 |   7 |

Find the last digit that appears in each line

#+begin_src sqlite :db ./day01.db
drop table if exists maximums;
create table maximums as
with min_char_id(line_id, char_id) as (select line_id, max(char_id) from ints group by line_id)
select line_id, chr
from ints
         join min_char_id using (line_id, char_id)
#+end_src	

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select line_id, chr from maximums  limit 10
#+end_src

#+RESULTS:
| line_id | chr |
|---------+-----|
|       1 |   9 |
|       2 |   4 |
|       3 |   9 |
|       4 |   6 |
|       5 |   2 |
|       6 |   4 |
|       7 |   8 |
|       8 |   3 |
|       9 |   2 |
|      10 |   6 |


Construct minimum-maximum pairs

#+begin_src sqlite :db ./day01.db
drop table if exists pairs;
create table pairs as
select line_id, cast(mn.chr || mx.chr as int) as pair
from maximums as mx
         join minimums as mn using (line_id)
#+end_src	

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select line_id, pair from pairs  limit 10
#+end_src

#+RESULTS:
| line_id | pair |
|---------+------|
|       1 |   99 |
|       2 |   34 |
|       3 |   99 |
|       4 |   86 |
|       5 |   62 |
|       6 |   24 |
|       7 |   28 |
|       8 |   23 |
|       9 |   22 |
|      10 |   76 |


Calculate the sum of all pairs

 #+begin_src sqlite :db ./day01.db :colnames yes :exports both
select sum(pair)  as Result from pairs
#+end_src

#+RESULTS:
| Result |
|--------|
|  55477 |


* Part 2


Create a table to map numeric and word strings to digits

#+begin_src sqlite :db ./day01.db
drop table if exists digits;
create table digits as
with digits(label, digit) as (values ('one', 1),
                                     ('two', 2),
                                     ('three', 3),
                                     ('four', 4),
                                     ('five', 5),
                                     ('six', 6),
                                     ('seven', 7),
                                     ('eight', 8),
                                     ('nine', 9))
select *
from digits
union
select cast(digit as string), digit
from digits
union
select '0', 0
#+end_src	

#+RESULTS:


#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select * from digits
#+end_src

#+RESULTS:
| label | digit |
|-------+-------|
|     1 |     1 |
|     2 |     2 |
|     3 |     3 |
|     4 |     4 |
|     5 |     5 |
|     6 |     6 |
|     7 |     7 |
|     8 |     8 |
|     9 |     9 |
|     0 |     0 |
| eight |     8 |
|  five |     5 |
|  four |     4 |
|  nine |     9 |
|   one |     1 |
| seven |     7 |
|   six |     6 |
| three |     3 |
|   two |     2 |


Convert each line back to a string
#+begin_src sqlite :db ./day01.db
drop table if exists lines;
create table lines as
select line_id, group_concat(chr, '') as line
from input
group by line_id
#+end_src	  

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select * from lines limit 10
#+end_src

#+RESULTS:
| line_id | line                       |
|---------+----------------------------|
|       1 | 9eightone                  |
|       2 | hczsqfour3nxm5seven4       |
|       3 | 9twopjqkghmbone            |
|       4 | rhrfthv886vflthreeztvzs    |
|       5 | tlbtwo62five               |
|       6 | ninetwonine234nvtlzxzczx   |
|       7 | 28sevenseven               |
|       8 | 2sevensxszqdhjg2threexzjj3 |
|       9 | 2fvq                       |
|      10 | 781dk97eight26             |

Get the index of each digit in the input strings

#+begin_src sqlite :db ./day01.db
drop table if exists part2_ints;
create table part2_ints as
with ints(line_id, _idx, digit, label) as (select line_id, instr(line, label) as _idx, digit, label
                                           from lines
                                                    join digits)
select line_id, _idx - 1 as idx, digit, label, length(label) as len
from ints
where _idx != 0
#+end_src	  

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select * from part2_ints limit 10
#+end_src

#+RESULTS:
| line_id | idx | digit | label | len |
|---------+-----+-------+-------+-----|
|       1 |   0 |     9 | 9     |   1 |
|       1 |   1 |     8 | eight |   5 |
|       1 |   6 |     1 | one   |   3 |
|       2 |   9 |     3 | 3     |   1 |
|       2 |  19 |     4 | 4     |   1 |
|       2 |  13 |     5 | 5     |   1 |
|       2 |   5 |     4 | four  |   4 |
|       2 |  14 |     7 | seven |   5 |
|       3 |   0 |     9 | 9     |   1 |
|       3 |  12 |     1 | one   |   3 |


Check for overlaps, there are 38 cases of overlaps

#+begin_src sqlite :db ./day01.db
drop table if exists overlaps;
create table overlaps as
select line_id,
       a.idx   as a_idx,
       a.len   as a_len,
       a.digit as a_digit,
       a.label as a_label,
       b.idx   as b_idx,
       b.len   as b_len,
       b.digit as b_digit,
       b.label as b_label
from part2_ints as a
         join part2_ints as b using (line_id)
where (((a.idx < b.idx and b.idx < a.idx + a.len) or (b.idx < a.idx and a.idx < b.idx + b.len)))
  and a.idx < b.idx 
#+end_src

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
   select * from overlaps limit 10
#+end_src

#+RESULTS:
| line_id | a_idx | a_len | a_digit | a_label | b_idx | b_len | b_digit | b_label |
|---------+-------+-------+---------+---------+-------+-------+---------+---------|
|      15 |    11 |     5 |       8 | eight   |    15 |     3 |       2 | two     |
|      18 |     6 |     3 |       1 | one     |     8 |     5 |       8 | eight   |
|     109 |     1 |     3 |       2 | two     |     3 |     3 |       1 | one     |
|     147 |     3 |     5 |       8 | eight   |     7 |     3 |       2 | two     |
|     166 |     1 |     3 |       1 | one     |     3 |     5 |       8 | eight   |
|     172 |    12 |     5 |       8 | eight   |    16 |     3 |       2 | two     |
|     229 |     1 |     3 |       1 | one     |     3 |     5 |       8 | eight   |
|     249 |     3 |     3 |       2 | two     |     5 |     3 |       1 | one     |
|     259 |    52 |     3 |       2 | two     |    54 |     3 |       1 | one     |
|     278 |    11 |     3 |       2 | two     |    13 |     3 |       1 | one     |

Check that no line contains more than one overlap, this would mean that the second number can simply be dropped

Count the number of overlaps in each line. No line contains more than 1 overlap

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
with counts(line_id, overlaps) as (select line_id, count(*) from overlaps group by line_id)
select count(*) as Count, overlaps as Overlaps
from counts
#+end_src

#+RESULTS:
| Count | Overlaps |
|-------+----------|
|    38 |        1 |



Create a table of removable digits, these are ones that overlap existing digits.

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  drop table if exists removable;
  create table removable as
  select line_id, b_idx as idx from overlaps       
#+end_src	

#+RESULTS:



  Find the first digit that appears in each line

#+begin_src sqlite :db ./day01.db
drop table if exists part2_minimums;
create table part2_minimums as
with min_char_id(line_id, idx) as (select line_id, min(idx) from part2_ints group by line_id)
select line_id, digit
from part2_ints
         join min_char_id using (line_id, idx)
#+end_src	

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select * from part2_minimums  limit 10
#+end_src

#+RESULTS:
| line_id | digit |
|---------+-------|
|       1 |     9 |
|       2 |     4 |
|       3 |     9 |
|       4 |     8 |
|       5 |     2 |
|       6 |     9 |
|       7 |     2 |
|       8 |     2 |
|       9 |     2 |
|      10 |     7 |

Find the last digit that appears in each line

#+begin_src sqlite :db ./day01.db
drop table if exists part2_maximums;
create table part2_maximums as
with min_char_id(line_id, idx) as (select line_id, max(part2_ints.idx)
                                   from part2_ints
                                            left join removable using (line_id, idx)
                                   where removable.idx is null
                                   group by line_id)
select line_id, digit
from part2_ints
         join min_char_id using (line_id, idx)
#+end_src	

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select * from part2_maximums  limit 10
#+end_src

#+RESULTS:
| line_id | digit |
|---------+-------|
|       1 |     1 |
|       2 |     4 |
|       3 |     1 |
|       4 |     3 |
|       5 |     5 |
|       6 |     4 |
|       7 |     7 |
|       8 |     3 |
|       9 |     2 |
|      10 |     6 |


Construct minimum-maximum pairs

#+begin_src sqlite :db ./day01.db
drop table if exists part2_pairs;
create table part2_pairs as
select line_id, mn.digit * 10 + mx.digit as pair
from part2_maximums as mx
         join part2_minimums as mn using (line_id)
#+end_src	

#+RESULTS:

#+begin_src sqlite :db ./day01.db :colnames yes :exports both
  select line_id, pair from part2_pairs limit 10
#+end_src

#+RESULTS:
| line_id | pair |
|---------+------|
|       1 |   91 |
|       2 |   44 |
|       3 |   91 |
|       4 |   83 |
|       5 |   25 |
|       6 |   94 |
|       7 |   27 |
|       8 |   23 |
|       9 |   22 |
|      10 |   76 |

Calculate the sum of all pairs

 #+begin_src sqlite :db ./day01.db :colnames yes :exports both
select sum(pair)  as Result from part2_pairs
#+end_src

#+RESULTS:
| Result |
|--------|
|  54431 |
